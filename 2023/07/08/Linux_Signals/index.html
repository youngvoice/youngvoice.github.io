<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"youngvoice.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="what happended when you press CTRL-C?">
<meta property="og:type" content="article">
<meta property="og:title" content="the mechanism of linux signal">
<meta property="og:url" content="https://youngvoice.github.io/2023/07/08/Linux_Signals/index.html">
<meta property="og:site_name" content="I am thinking...">
<meta property="og:description" content="what happended when you press CTRL-C?">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-07-08T00:00:00.000Z">
<meta property="article:modified_time" content="2024-07-20T10:36:34.034Z">
<meta property="article:author" content="youngvoice">
<meta property="article:tag" content="cs">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="signal">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://youngvoice.github.io/2023/07/08/Linux_Signals/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://youngvoice.github.io/2023/07/08/Linux_Signals/","path":"2023/07/08/Linux_Signals/","title":"the mechanism of linux signal"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>the mechanism of linux signal | I am thinking...</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?d0151213913d23785e89cc44331002a7"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">I am thinking...</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">46</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">66</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">48</span></a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-signal-and-What-is-it-used-to-do"><span class="nav-number">1.</span> <span class="nav-text">What is signal? and What is it used to do?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%EF%BC%8C%E4%BF%A1%E5%8F%B7%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%B8%8A%E7%9A%84%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">1.0.1.</span> <span class="nav-text">特别注意，信号和硬件上的异常中断的区别和联系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-can-we-produce-a-signal-and-call-our-own-function-to-handle-it"><span class="nav-number">2.</span> <span class="nav-text">How can we produce a signal and call our own function to handle it?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-What-signal-exist-and-How-to-produce-a-signal"><span class="nav-number">2.1.</span> <span class="nav-text">(1)What signal exist? and How to produce a signal?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What-signal-can-system-support"><span class="nav-number">2.1.1.</span> <span class="nav-text">What signal can system support?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-condition-can-produce-signal"><span class="nav-number">2.1.2.</span> <span class="nav-text">What condition can produce signal?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-How-to-handle-a-signal-through-our-own-function"><span class="nav-number">2.2.</span> <span class="nav-text">(2) How to handle a signal through our own function?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#example"><span class="nav-number">2.3.</span> <span class="nav-text">example</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-relationship-is-needed-between-the-process-sending-signal-and-the-process-receiving-signal"><span class="nav-number">3.</span> <span class="nav-text">What relationship is needed between the process sending signal and the process receiving signal???</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%8F%91%E9%80%81%E6%97%B6%E7%9A%84%E6%9D%83%E9%99%90%E8%A6%81%E6%B1%82%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">如何给特定进程组发送信号，以及发送时的权限要求？？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-to-protect-a-critical-region-of-code-from-a-specific-signal-%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E5%9C%A8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B6%E4%BB%96%E9%83%A8%E5%88%86%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%EF%BC%9F%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">How to protect a critical region of code from a specific signal? (如何安全的在信号处理程序和进程的其他部分共享数据？？)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#critical-region%EF%BC%88%E6%AD%A4%E5%A4%84%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8E%E4%B8%8B%E9%9D%A2%E6%9C%89%E7%82%B9%E5%83%8F%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">critical region（此处的情况与下面有点像）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-a-condition-%E7%AD%89%E6%9F%90%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F"><span class="nav-number">5.2.</span> <span class="nav-text">wait a condition(等某个事件发生)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-to-implement-sleep-using-alarm"><span class="nav-number">6.</span> <span class="nav-text">How to implement sleep() using alarm() ???</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E5%8F%88%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%EF%BC%9F%EF%BC%9F%EF%BC%88%E5%8F%AF%E8%83%BD%E6%98%AF%E7%9B%B8%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%EF%BC%8C%E4%B9%9F%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%EF%BC%89"><span class="nav-number">7.</span> <span class="nav-text">如何避免正在执行信号处理函数时，又收到信号处理请求？？（可能是相同类型的信号，也可能是不同类型的信号）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E7%A8%8B%E5%BA%8F%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%B9%B6%E8%B0%83%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">在程序正在执行一个不可重入函数时，信号发生并调用相同的函数，会发生什么情况？？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-difference-exists-between-thread-safe-and-async-signal-safe"><span class="nav-number">9.</span> <span class="nav-text">What difference exists between thread-safe and async-signal safe???</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-the-meaning-of-that-SIGKILL-and-SIGSTOP-%E2%80%98s-default-dispositions-cannot-be-changed"><span class="nav-number">10.</span> <span class="nav-text">What is the meaning of that SIGKILL and SIGSTOP ‘s default dispositions cannot be changed???</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#signal-%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">signal 和多线程的关系？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8Csignal-%E6%98%AF%E5%A6%82%E4%BD%95-delivered"><span class="nav-number">12.</span> <span class="nav-text">在多线程的环境下，signal 是如何 delivered???</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-the-signal-generating-and-signal-delivering-does-perspective"><span class="nav-number">13.</span> <span class="nav-text">What the signal generating and signal delivering does perspective???</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-is-the-difference-between-pending-signals-and-masking-signals"><span class="nav-number">14.</span> <span class="nav-text">What is the difference between pending signals and masking signals???</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Can-we-have-more-than-one-signal-pending-for-a-process"><span class="nav-number">15.</span> <span class="nav-text">Can we have more than one signal pending for a process?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-restart-a-read-operation-that-is-interrupted-by-a-signal"><span class="nav-number">16.</span> <span class="nav-text">How restart a read operation that is interrupted by a signal?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reentrant-function-errno"><span class="nav-number">17.</span> <span class="nav-text">reentrant function (errno)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reliable-and-unreliable-signals"><span class="nav-number">18.</span> <span class="nav-text">reliable and unreliable signals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8-printf-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">可重入与信号处理程序中调用 printf 的问题？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%99%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%BC%A0%E9%80%92%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%94%B6%E5%88%B0%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%80%BC%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">20.</span> <span class="nav-text">给信号处理程序传递的参数中有一个收到的信号值，这样有什么好处？？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E8%B0%83%E8%AF%95%E6%88%96%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E5%BD%93%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E5%AE%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%90%8E%EF%BC%8C%E6%8E%A5%E7%9D%80%E8%BF%90%E8%A1%8C%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">在调试或演示代码中，当主程序设置完信号处理程序后，接着运行什么？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8-fork-%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%88%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">在 fork 之后，子进程和父进程的信号处理有什么关系？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SIGCHLD-%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%BD%A2%E6%88%90%E4%BB%A5%E5%8F%8A%E5%AD%90%E8%BF%9B%E7%A8%8B-exit-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">SIGCHLD 与僵尸进程形成以及子进程 exit 之间的关系？？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-%E4%B8%8A%EF%BC%8C%E5%90%8E%E5%8F%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7-SIGINT-%E5%92%8C-SIGQUIT%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">linux 上，后台执行的进程如何处理信号 SIGINT 和 SIGQUIT？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%99%E9%87%8C%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E6%89%A7%E8%A1%8C-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B-%E7%9A%84shell%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%A1%AE%E8%AE%A4%E4%B8%80%E4%B8%8B%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">24.1.</span> <span class="nav-text">这里的处理方式，需要在执行 后台进程 的shell代码中确认一下？？？？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strsignal-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">strsignal 与线程安全？？？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#How-to-map-between-signal-numbers-and-names"><span class="nav-number">25.1.</span> <span class="nav-text">How to map between signal numbers and names?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Scenarios"><span class="nav-number">26.</span> <span class="nav-text">Scenarios</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#How-we-can-achieve-to-unblock-a-signal-and-then-pause-waiting-for-the-previously-blocked-signal-to-occur"><span class="nav-number">26.1.</span> <span class="nav-text">How we can achieve to unblock a signal and then pause, waiting for the previously blocked signal to occur?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pause-and-wait"><span class="nav-number">26.2.</span> <span class="nav-text">pause and wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E7%A8%8B%E5%BA%8F%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E9%9C%80%E8%A6%81%E9%80%80%E5%87%BA%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%88%A0%E9%99%A4%E7%A8%8B%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="nav-number">26.3.</span> <span class="nav-text">当程序收到信号需要退出时，可以在信号处理程序中删除程序创建的临时文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pause-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">pause 系统调用的实现？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pause-%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8F%AA%E5%9C%A8%E6%8E%A5%E6%94%B6%E5%88%B0%E5%8F%AF%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7%E6%97%B6%E8%BF%94%E5%9B%9E%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">pause 是如何做到只在接收到可捕获信号时返回的？？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%B1%E4%B8%8A%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%AF%E4%BB%A5%E6%83%B3%E5%88%B0%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E6%9D%A1%E4%BB%B6%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">由上面的问题可以想到进程状态切换的条件都有哪些？？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8E-control-terminal-%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%88%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%EF%BC%89%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">与 control terminal 相关的信号是如何实现的（如何产生）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">31.</span> <span class="nav-text">内核的支持</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-key-data-structure-and-function-related-to-signal"><span class="nav-number">32.</span> <span class="nav-text">The key data structure and function related to signal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-the-kernel-support-the-above-mechanism-of-signal"><span class="nav-number">33.</span> <span class="nav-text">How the kernel support the above mechanism of signal???</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#do-signal%E5%87%BD%E6%95%B0%E5%92%8Chandle-signal%E5%87%BD%E6%95%B0%E9%83%BD%E5%AE%8C%E6%88%90%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%88%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="nav-number">34.</span> <span class="nav-text">do_signal函数和handle_signal函数都完成了哪些工作？？？（核心机制）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#What-the-function-do-signal-does"><span class="nav-number">35.</span> <span class="nav-text">What the function do_signal does?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%A0%B7%E9%80%9A%E8%BF%87-handle-signal-%E5%87%BD%E6%95%B0%E6%9D%A5%E6%89%A7%E8%A1%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">怎么样通过 handle_signal 函数来执行信号处理程序？？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BD%93%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%A2%AB%E6%8C%82%E8%B5%B7%E7%9A%84%E4%BF%A1%E5%8F%B7%E7%AD%89%E5%BE%85%E8%A2%AB%E5%A4%84%E7%90%86%E6%97%B6%EF%BC%8C%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">当有多个被挂起的信号等待被处理时，信号处理的流程是什么样的？？？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Some-classical-signal-produced-by-keyboard"><span class="nav-number">38.</span> <span class="nav-text">Some classical signal produced by keyboard??</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-the-alarm-is-implement"><span class="nav-number">39.</span> <span class="nav-text">How the alarm is implement?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%BB%99%E8%87%AA%E5%B7%B1%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">如何给自己发送信号？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">41.</span> <span class="nav-text">Reference</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#keyword"><span class="nav-number">42.</span> <span class="nav-text">keyword</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#permission-check"><span class="nav-number">43.</span> <span class="nav-text">permission check</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-to-support-critical-region-and-masking-signal"><span class="nav-number">44.</span> <span class="nav-text">How to support critical region and masking signal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E8%AE%BE%E7%BD%AEhandle%E6%97%B6%E5%AF%B9-SIGKILL-and-SIGSTOP-%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="nav-number">45.</span> <span class="nav-text">内核设置handle时对 SIGKILL and SIGSTOP 的检查</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5"><span class="nav-number">46.</span> <span class="nav-text">内核在多线程环境下的信号分发策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9%E8%A2%AB%E4%BF%A1%E5%8F%B7%E6%89%93%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%87%8D%E5%90%AF%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">47.</span> <span class="nav-text">内核对被信号打断的系统调用重启的支持</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%AF%B9sigaction-%E5%92%8C-signal%E7%9A%84%E6%94%AF%E6%8C%81%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="nav-number">48.</span> <span class="nav-text">内核对sigaction 和 signal的支持区别在哪？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8E%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">49.</span> <span class="nav-text">与信号相关的系统调用如何实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#linux-signal-produce-and-delivery"><span class="nav-number">50.</span> <span class="nav-text">linux signal produce and delivery</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#try-one-simple-example"><span class="nav-number">50.1.</span> <span class="nav-text">try one simple example</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#How-many-signals-can-we-produce"><span class="nav-number">51.</span> <span class="nav-text">How many signals can we produce?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Which-common-scenarios-are-related-to-signals"><span class="nav-number">52.</span> <span class="nav-text">Which common scenarios are related to signals?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#how-to-produce-signal"><span class="nav-number">53.</span> <span class="nav-text">how to produce signal?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#how-to-delivery-signal"><span class="nav-number">54.</span> <span class="nav-text">how to delivery signal?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#executing-a-signal-handler"><span class="nav-number">54.1.</span> <span class="nav-text">executing a signal handler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%B0%86%E4%BC%9A%E9%81%87%E5%88%B0%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="nav-number">54.1.1.</span> <span class="nav-text">执行一个信号处理程序将会遇到哪些问题？？？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#the-solution-for-above-problem"><span class="nav-number">54.1.2.</span> <span class="nav-text">the solution for above problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-to-implement-the-above-step"><span class="nav-number">54.1.3.</span> <span class="nav-text">How to implement the above step?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%E5%90%8E%E4%B8%BA%E5%95%A5%E8%BF%98%E8%A6%81%E5%9B%9E%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E5%8E%BB%E6%81%A2%E5%A4%8D%E7%8E%B0%E5%9C%BA%EF%BC%9F%EF%BC%9F%EF%BC%88%E7%9B%B4%E6%8E%A5%E8%B7%B3%E5%88%B0%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F%EF%BC%9F%EF%BC%89"><span class="nav-number">55.</span> <span class="nav-text">信号处理函数执行完成后为啥还要回到内核态去恢复现场？？（直接跳到正常的执行流程不行吗？？）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%EF%BC%9F%EF%BC%9F%EF%BC%88%E5%9C%A8%E5%86%85%E6%A0%B8%E6%80%81%E5%A0%86%E6%A0%88%E8%BF%98%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E5%BC%82%E5%B8%B8%E5%A0%86%E6%A0%88%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%89"><span class="nav-number">56.</span> <span class="nav-text">发生信号的时候，正常的执行流的上下文保存在哪？？（在内核态堆栈还是用户态异常堆栈？？？）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#how-to-config-signal-disposition"><span class="nav-number">57.</span> <span class="nav-text">how to config signal disposition?</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">youngvoice</p>
  <div class="site-description" itemprop="description">to record interesting things and questions</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://youngvoice.github.io/2023/07/08/Linux_Signals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="youngvoice">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="I am thinking...">
      <meta itemprop="description" content="to record interesting things and questions">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="the mechanism of linux signal | I am thinking...">
      <meta itemprop="description" content="what happended when you press CTRL-C?">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          the mechanism of linux signal
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-08 00:00:00" itemprop="dateCreated datePublished" datetime="2023-07-08T00:00:00+00:00">2023-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-07-20 10:36:34" itemprop="dateModified" datetime="2024-07-20T10:36:34+00:00">2024-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cs/" itemprop="url" rel="index"><span itemprop="name">cs</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cs/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/cs/linux/signal/" itemprop="url" rel="index"><span itemprop="name">signal</span></a>
        </span>
    </span>

  
    <span id="/2023/07/08/Linux_Signals/" class="post-meta-item leancloud_visitors" data-flag-title="the mechanism of linux signal" title="Views">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span class="leancloud-visitors-count"></span>
    </span>
</div>

            <div class="post-description">what happended when you press CTRL-C?</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="What-is-signal-and-What-is-it-used-to-do"><a href="#What-is-signal-and-What-is-it-used-to-do" class="headerlink" title="What is signal? and What is it used to do?"></a>What is signal? and What is it used to do?</h1><p>Signals are software interrupts. Signals provide a way of handling asynchronous events(for process).（这个地方是不是需要修正一下，通过下面的知识，可以看出来，信号可以处理 同步事件和异步事件）(补充：这的里 asynchronous 应该是与程序的正常执行控制流程（plan）异步的意思)</p>
<p>The occurrence of a signal may be synchronous or asynchronous to the process or thread, depending on the source of the signal and underlying reason or cause. </p>
<p>Synchronous signals occur as a direct result of the executing instruction stream, where an unrecoverable error requires an immediate termination of the process. Such sinals are directed to the thread which caused the error with its execution stream. As an error of this type causes a trap into a kernel trap handler, synchronous signals are sometimes referred to as traps.</p>
<p>Asynchronous signals are external to the current execution context. Asynchronous signals are also aptly referred to as interrupts. It can be produced by sending from another process or thread via a kill(2), _lwp_kill(2), sigsend(2) system call, or a thr_kill(3), pthread_kill(3), sigqueue(3) library invocation. It can also be produced by interrupt handler in kernel code.</p>
<h3 id="特别注意，信号和硬件上的异常中断的区别和联系"><a href="#特别注意，信号和硬件上的异常中断的区别和联系" class="headerlink" title="特别注意，信号和硬件上的异常中断的区别和联系"></a>特别注意，信号和硬件上的异常中断的区别和联系</h3><p>当硬件上收到异常或中断时，内核中的处理程序可以选择给一些进程或线程发送信号</p>
<blockquote>
<blockquote>
<p>If you are familiar with interrupts, signals are very similar in their behavior. The difference is that while interrupts are sent to the operating system by the hardware, signals are sent to the process by the operating system, or by other processes. Note that signals have nothing to do with software interrupts, which are still sent by the hardware.(software interrupts is sent by the cpu itself, in this case)</p>
</blockquote>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://www.cs.kent.edu/~ruttan/sysprog/lectures/signals.html#masking">http://www.cs.kent.edu/~ruttan/sysprog/lectures/signals.html#masking</a></p>
<p>Note:</p>
<p><strong>interrupts are sent to the operating system by the hardware, signals are sent to the process by the operating system, or by other processes.</strong></p>
<h1 id="How-can-we-produce-a-signal-and-call-our-own-function-to-handle-it"><a href="#How-can-we-produce-a-signal-and-call-our-own-function-to-handle-it" class="headerlink" title="How can we produce a signal and call our own function to handle it?"></a>How can we produce a signal and call our own function to handle it?</h1><h2 id="1-What-signal-exist-and-How-to-produce-a-signal"><a href="#1-What-signal-exist-and-How-to-produce-a-signal" class="headerlink" title="(1)What signal exist? and How to produce a signal?"></a>(1)What signal exist? and How to produce a signal?</h2><p>The most common way of producing a signal is uing the keyboard. There are certain key presses that are interpreted by the system(TTY) as requests to send signals to the process with which we are interacting(前台进程).<br>e.g<br>produce a SIGINT to interrupt a process by key CTRL-C</p>
<h3 id="What-signal-can-system-support"><a href="#What-signal-can-system-support" class="headerlink" title="What signal can system support?"></a>What signal can system support?</h3><p>To use command “kill -l” list the system support signals.</p>
<h3 id="What-condition-can-produce-signal"><a href="#What-condition-can-produce-signal" class="headerlink" title="What condition can produce signal?"></a>What condition can produce signal?</h3><ul>
<li><p>用户在终端按下组合键时，终端驱动程序会发送信号给前台进程，例如终端作业控制中常常使用的(“CTRL-C,CTRL-Z,CTRL-\“)分别产生(SIGINT,SIGSTOP,SIGQUIT)<br>generated by a keyboard entry from the controlling terminal</p>
</li>
<li><p>sending signals by the command(usually internal to the shell) kill fg(SIGCONT)(SIGSTOP 与 SIGCONT为一对相反的信号)</p>
</li>
<li><p>sending signals using system call, 通过调用kill函数，从一个进程向另一个进程发送信号</p>
</li>
<li><p>硬件异常，譬如，（1）当进程执行了除0操作，内核收到运算单元产生的异常后将会发送SIGFPE信号给进程，（2）当前进程访问非法内存地址，内核收到mmu产生的异常后将发送SIGSEGV信号给进程。</p>
</li>
<li><p>内核检测到某种条件，譬如，闹钟超时产生SIGALRM信号，向读端已经关闭的管道写数据时产生SIGPIPE信号。</p>
</li>
</ul>
<h2 id="2-How-to-handle-a-signal-through-our-own-function"><a href="#2-How-to-handle-a-signal-through-our-own-function" class="headerlink" title="(2) How to handle a signal through our own function?"></a>(2) How to handle a signal through our own function?</h2><p>call sigaction(2) to register handler for a signal</p>
<h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here is the %dth signal\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> global = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;waiting for signal\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ref:<br><a target="_blank" rel="noopener" href="https://devopedia.org/linux-signals">https://devopedia.org/linux-signals</a></p>
<hr>
<h1 id="What-relationship-is-needed-between-the-process-sending-signal-and-the-process-receiving-signal"><a href="#What-relationship-is-needed-between-the-process-sending-signal-and-the-process-receiving-signal" class="headerlink" title="What relationship is needed between the process sending signal and the process receiving signal???"></a>What relationship is needed between the process sending signal and the process receiving signal???</h1><p>从一个进程调用 kill 系统调用是不可以随意给别的进程发送信号的，至少发送进程需要权限，否则会发送失败。</p>
<ol>
<li>有CAP_KILL 权限的进程能够给任何进程发送信号。</li>
<li>发送进程的有效或真正的用户 ID 必须等于接收进程的真正或保存的用户 ID</li>
</ol>
<p>如果signo 是 0， 调用不会发送信号，但是会进程错误检查，这可以用来测试一个进程是否有权限给另一个进程发送信号。</p>
<h1 id="如何给特定进程组发送信号，以及发送时的权限要求？？？"><a href="#如何给特定进程组发送信号，以及发送时的权限要求？？？" class="headerlink" title="如何给特定进程组发送信号，以及发送时的权限要求？？？"></a>如何给特定进程组发送信号，以及发送时的权限要求？？？</h1><p>killpg(pgrp, signo) 等价于 kill(-pgrp, signo)</p>
<h1 id="How-to-protect-a-critical-region-of-code-from-a-specific-signal-如何安全的在信号处理程序和进程的其他部分共享数据？？"><a href="#How-to-protect-a-critical-region-of-code-from-a-specific-signal-如何安全的在信号处理程序和进程的其他部分共享数据？？" class="headerlink" title="How to protect a critical region of code from a specific signal? (如何安全的在信号处理程序和进程的其他部分共享数据？？)"></a>How to protect a critical region of code from a specific signal? (如何安全的在信号处理程序和进程的其他部分共享数据？？)</h1><p>由于信号处理程序是异步执行，所以信号处理程序不能对进程被中断时的操作有任何假设。<br>可以暂时阻止接收信号(Masking signals)</p>
<h2 id="critical-region（此处的情况与下面有点像）"><a href="#critical-region（此处的情况与下面有点像）" class="headerlink" title="critical region（此处的情况与下面有点像）"></a>critical region（此处的情况与下面有点像）</h2><p>这个地方的 临界区 要求有点特殊，要求从 临界区 出来之后等待一个信号的发生，也就是当我们做完临界区的工作之后要等一个事件的发生（实际上，一般情况我们从临界区出来后不会再关注共享资源的那个信号什么时候发生）（we want to unblock a signal and then pause, waiting for the previously blocked signal to occur？）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sigemptyset(&amp;zeromask);</span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *  Critical region of code</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    sigsuspend(&amp;zeromask):</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="wait-a-condition-等某个事件发生"><a href="#wait-a-condition-等某个事件发生" class="headerlink" title="wait a condition(等某个事件发生)"></a>wait a condition(等某个事件发生)</h2><p>下面的信号处理函数可以处理多个信号，所以综合起来看，这里的场景与上面的差不多</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sig_int</span><span class="params">(<span class="type">int</span> signo)</span>      <span class="comment">/* one signal handler for SIGQUIT */</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (signo == SIGQUIT)</span><br><span class="line">                quitflag = <span class="number">1</span>;   <span class="comment">/* set flag for main loop */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sigemptyset(&amp;zeromask);</span><br><span class="line">    sigemptyset(&amp;newmask);</span><br><span class="line">    sigaddset(&amp;newmask, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;newmask, &amp;oldmask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (quitflag == <span class="number">0</span>)</span><br><span class="line">        sigsuspend(&amp;zeromask);</span><br><span class="line">    quitflag = <span class="number">0</span>;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;oldmask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="How-to-implement-sleep-using-alarm"><a href="#How-to-implement-sleep-using-alarm" class="headerlink" title="How to implement sleep() using alarm() ???"></a>How to implement sleep() using alarm() ???</h1><h1 id="如何避免正在执行信号处理函数时，又收到信号处理请求？？（可能是相同类型的信号，也可能是不同类型的信号）"><a href="#如何避免正在执行信号处理函数时，又收到信号处理请求？？（可能是相同类型的信号，也可能是不同类型的信号）" class="headerlink" title="如何避免正在执行信号处理函数时，又收到信号处理请求？？（可能是相同类型的信号，也可能是不同类型的信号）"></a>如何避免正在执行信号处理函数时，又收到信号处理请求？？（可能是相同类型的信号，也可能是不同类型的信号）</h1><p>Masking signals</p>
<h1 id="在程序正在执行一个不可重入函数时，信号发生并调用相同的函数，会发生什么情况？？？"><a href="#在程序正在执行一个不可重入函数时，信号发生并调用相同的函数，会发生什么情况？？？" class="headerlink" title="在程序正在执行一个不可重入函数时，信号发生并调用相同的函数，会发生什么情况？？？"></a>在程序正在执行一个不可重入函数时，信号发生并调用相同的函数，会发生什么情况？？？</h1><ol>
<li>进程正在写文件或申请内存，信号处理程序也向同一个文件写入或也在调用 malloc 申请内存会怎么样？</li>
<li>进程正在调用一个使用静态缓存的函数，例如 strsignal()，此时信号发生，会是什么情况？</li>
</ol>
<h1 id="What-difference-exists-between-thread-safe-and-async-signal-safe"><a href="#What-difference-exists-between-thread-safe-and-async-signal-safe" class="headerlink" title="What difference exists between thread-safe and async-signal safe???"></a>What difference exists between thread-safe and async-signal safe???</h1><h1 id="What-is-the-meaning-of-that-SIGKILL-and-SIGSTOP-‘s-default-dispositions-cannot-be-changed"><a href="#What-is-the-meaning-of-that-SIGKILL-and-SIGSTOP-‘s-default-dispositions-cannot-be-changed" class="headerlink" title="What is the meaning of that SIGKILL and SIGSTOP ‘s default dispositions cannot be changed???"></a>What is the meaning of that SIGKILL and SIGSTOP ‘s default dispositions cannot be changed???</h1><p>对信号 SIGKILL 和 SIGSTOP 而言，在应用上有什么特别之处？<br>it is meaning that these signals are non-catchable</p>
<h1 id="signal-和多线程的关系？"><a href="#signal-和多线程的关系？" class="headerlink" title="signal 和多线程的关系？"></a>signal 和多线程的关系？</h1><p>线程拥有私有的 sigmask， 但是当创建线程时，可以通过给 clone 传 CLONE_SIGHAND 来让属于同一个进程的线程共享 current-&gt;sig</p>
<h1 id="在多线程的环境下，signal-是如何-delivered"><a href="#在多线程的环境下，signal-是如何-delivered" class="headerlink" title="在多线程的环境下，signal 是如何 delivered???"></a>在多线程的环境下，signal 是如何 delivered???</h1><p>信号的deliver是线程私有的，Asynchronous signals are delivered to the first thread found not blocking the signal. Synchronous signals happening in the context of a given thread are delivered to that thread.</p>
<h1 id="What-the-signal-generating-and-signal-delivering-does-perspective"><a href="#What-the-signal-generating-and-signal-delivering-does-perspective" class="headerlink" title="What the signal generating and signal delivering does perspective???"></a>What the signal generating and signal delivering does perspective???</h1><p>There is a brief period of time between the time a signal is generated and the time a signal is delivered.</p>
<h1 id="What-is-the-difference-between-pending-signals-and-masking-signals"><a href="#What-is-the-difference-between-pending-signals-and-masking-signals" class="headerlink" title="What is the difference between pending signals and masking signals???"></a>What is the difference between pending signals and masking signals???</h1><p>the signal mask of a process is the set of signals currently blocked from delivery to that process.<br>the sigpending function returns the set of signals that are blocked from delivery.</p>
<h1 id="Can-we-have-more-than-one-signal-pending-for-a-process"><a href="#Can-we-have-more-than-one-signal-pending-for-a-process" class="headerlink" title="Can we have more than one signal pending for a process?"></a>Can we have more than one signal pending for a process?</h1><p>to tell the system “prevent the following signals from interrupting me, but remember if they do occur”</p>
<p>Yes, many standard signals can be pending for a process. However, only one instance of a given signal type can be pending. This is because pending and blocking of signals are implemented as bitmasks, with one bit for signal type.</p>
<h1 id="How-restart-a-read-operation-that-is-interrupted-by-a-signal"><a href="#How-restart-a-read-operation-that-is-interrupted-by-a-signal" class="headerlink" title="How restart a read operation that is interrupted by a signal?"></a>How restart a read operation that is interrupted by a signal?</h1><p>interrupt system call (also ref select and poll)<br>进程收到信号后，打断想read，write这样的系统调用，还需要考虑，被打断的系统调用是否会重启</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> ((n = read(fd, buf, BUFFSIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        <span class="comment">/* handle other errors */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="reentrant-function-errno"><a href="#reentrant-function-errno" class="headerlink" title="reentrant function (errno)"></a>reentrant function (errno)</h1><p>there is only one errno per thread, and we might potentially modify it. Therefore, as a general rule, when calling async-signal safe function, we should save and restore errno, because the called async-signal safe funcion may change errno.</p>
<h1 id="reliable-and-unreliable-signals"><a href="#reliable-and-unreliable-signals" class="headerlink" title="reliable and unreliable signals"></a>reliable and unreliable signals</h1><p>signal<br>sigaction</p>
<h1 id="可重入与信号处理程序中调用-printf-的问题？？"><a href="#可重入与信号处理程序中调用-printf-的问题？？" class="headerlink" title="可重入与信号处理程序中调用 printf 的问题？？"></a>可重入与信号处理程序中调用 printf 的问题？？</h1><h1 id="给信号处理程序传递的参数中有一个收到的信号值，这样有什么好处？？？"><a href="#给信号处理程序传递的参数中有一个收到的信号值，这样有什么好处？？？" class="headerlink" title="给信号处理程序传递的参数中有一个收到的信号值，这样有什么好处？？？"></a>给信号处理程序传递的参数中有一个收到的信号值，这样有什么好处？？？</h1><p>一个信号处理程序可以处理多个信号</p>
<h1 id="在调试或演示代码中，当主程序设置完信号处理程序后，接着运行什么？？"><a href="#在调试或演示代码中，当主程序设置完信号处理程序后，接着运行什么？？" class="headerlink" title="在调试或演示代码中，当主程序设置完信号处理程序后，接着运行什么？？"></a>在调试或演示代码中，当主程序设置完信号处理程序后，接着运行什么？？</h1><p>有几种选择，</p>
<ol>
<li>循环调用pause()<br>the pause() system call causes the process to halt execution, until a signal is received. It is surely better than a “busy wait” infinite loop. </li>
<li>循环调用sleep()</li>
<li>直接循环（busy wait）</li>
</ol>
<h1 id="在-fork-之后，子进程和父进程的信号处理有什么关系？"><a href="#在-fork-之后，子进程和父进程的信号处理有什么关系？" class="headerlink" title="在 fork 之后，子进程和父进程的信号处理有什么关系？"></a>在 fork 之后，子进程和父进程的信号处理有什么关系？</h1><p>核心问题在于父进程和子进程是否在共享同一个地址空间，这样的话，按道理在刚完成 fork 后，子进程应该完全继承了与父进程相同的信号语义。<br>在执行 exec 之后，所有的信号都被设置为默认操作（除非是忽略信号），即所有之前捕获的信号都被重置为默认操作，所有其他信号保持不变，因为 exec 之后，之前注册过的信号处理程序可能都不存在。</p>
<p>A child created via fork(2) inherits a copy of its parent’s signal dispositions.  During an execve(2), the dispositions  of  handled  signals are reset to the default; the dispositions of ignored signals are left unchanged. (man sigaction)</p>
<h1 id="SIGCHLD-与僵尸进程形成以及子进程-exit-之间的关系？？？"><a href="#SIGCHLD-与僵尸进程形成以及子进程-exit-之间的关系？？？" class="headerlink" title="SIGCHLD 与僵尸进程形成以及子进程 exit 之间的关系？？？"></a>SIGCHLD 与僵尸进程形成以及子进程 exit 之间的关系？？？</h1><h1 id="linux-上，后台执行的进程如何处理信号-SIGINT-和-SIGQUIT？"><a href="#linux-上，后台执行的进程如何处理信号-SIGINT-和-SIGQUIT？" class="headerlink" title="linux 上，后台执行的进程如何处理信号 SIGINT 和 SIGQUIT？"></a>linux 上，后台执行的进程如何处理信号 SIGINT 和 SIGQUIT？</h1><p>后台执行的进程会将 SIGINT 和 SIGQUIT 的处理方式设置为 SIG_IGN</p>
<h2 id="这里的处理方式，需要在执行-后台进程-的shell代码中确认一下？？？？"><a href="#这里的处理方式，需要在执行-后台进程-的shell代码中确认一下？？？？" class="headerlink" title="这里的处理方式，需要在执行 后台进程 的shell代码中确认一下？？？？"></a>这里的处理方式，需要在执行 后台进程 的shell代码中确认一下？？？？</h2><h1 id="strsignal-与线程安全？？？"><a href="#strsignal-与线程安全？？？" class="headerlink" title="strsignal 与线程安全？？？"></a>strsignal 与线程安全？？？</h1><h2 id="How-to-map-between-signal-numbers-and-names"><a href="#How-to-map-between-signal-numbers-and-names" class="headerlink" title="How to map between signal numbers and names?"></a>How to map between signal numbers and names?</h2><h1 id="Scenarios"><a href="#Scenarios" class="headerlink" title="Scenarios"></a>Scenarios</h1><h2 id="How-we-can-achieve-to-unblock-a-signal-and-then-pause-waiting-for-the-previously-blocked-signal-to-occur"><a href="#How-we-can-achieve-to-unblock-a-signal-and-then-pause-waiting-for-the-previously-blocked-signal-to-occur" class="headerlink" title="How we can achieve to unblock a signal and then pause, waiting for the previously blocked signal to occur?"></a>How we can achieve to unblock a signal and then pause, waiting for the previously blocked signal to occur?</h2><p>Before enter critical region we block a signal to prevent the signal interrupting. After executing the critical region, we want unblock the signal and then pause, waiting for the signal to wake up(how ensure not to lost any the signal, otherwise, there is possibility that the thread wait forever), and then continue execute.</p>
<p>the method is to use function sigsuspend.</p>
<h2 id="pause-and-wait"><a href="#pause-and-wait" class="headerlink" title="pause and wait"></a>pause and wait</h2><p>let process to sleep and wait for signal to wake up </p>
<h2 id="当程序收到信号需要退出时，可以在信号处理程序中删除程序创建的临时文件"><a href="#当程序收到信号需要退出时，可以在信号处理程序中删除程序创建的临时文件" class="headerlink" title="当程序收到信号需要退出时，可以在信号处理程序中删除程序创建的临时文件"></a>当程序收到信号需要退出时，可以在信号处理程序中删除程序创建的临时文件</h2><h1 id="pause-系统调用的实现？"><a href="#pause-系统调用的实现？" class="headerlink" title="pause 系统调用的实现？"></a>pause 系统调用的实现？</h1><p>pause() 系统调用，它可以使进程睡眠，直到进程收到处理或终止进程的信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(pause)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!signal_pending(current)) &#123;</span><br><span class="line">		__set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">		schedule();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -ERESTARTNOHAND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pause 只在接收到可捕获的信号时返回，并且在这种情况下该信号被处理（如果该信号被设置为被忽略，则进程不会被唤醒），pause() 系统调用返回 -1， 并将 errno 设置为 EINTR。</p>
<h1 id="pause-是如何做到只在接收到可捕获信号时返回的？？？"><a href="#pause-是如何做到只在接收到可捕获信号时返回的？？？" class="headerlink" title="pause 是如何做到只在接收到可捕获信号时返回的？？？"></a>pause 是如何做到只在接收到可捕获信号时返回的？？？</h1><p>因为 pause 系统调用只执行两个操作，它首先将进程置为可中断的睡眠状态。然后调用schedule()，切换到别的进程运行。<em><strong>最重要的是该进程实际上不等待任何事件，在接收到信号前，内核不会唤醒该进程。</strong></em></p>
<h1 id="由上面的问题可以想到进程状态切换的条件都有哪些？？？"><a href="#由上面的问题可以想到进程状态切换的条件都有哪些？？？" class="headerlink" title="由上面的问题可以想到进程状态切换的条件都有哪些？？？"></a>由上面的问题可以想到进程状态切换的条件都有哪些？？？</h1><h1 id="与-control-terminal-相关的信号是如何实现的（如何产生）？"><a href="#与-control-terminal-相关的信号是如何实现的（如何产生）？" class="headerlink" title="与 control terminal 相关的信号是如何实现的（如何产生）？"></a>与 control terminal 相关的信号是如何实现的（如何产生）？</h1><p>tty</p>
<hr>
<h1 id="内核的支持"><a href="#内核的支持" class="headerlink" title="内核的支持"></a>内核的支持</h1><h1 id="The-key-data-structure-and-function-related-to-signal"><a href="#The-key-data-structure-and-function-related-to-signal" class="headerlink" title="The key data structure and function related to signal"></a>The key data structure and function related to signal</h1><p>signal sets</p>
<h1 id="How-the-kernel-support-the-above-mechanism-of-signal"><a href="#How-the-kernel-support-the-above-mechanism-of-signal" class="headerlink" title="How the kernel support the above mechanism of signal???"></a>How the kernel support the above mechanism of signal???</h1><h1 id="do-signal函数和handle-signal函数都完成了哪些工作？？？（核心机制）"><a href="#do-signal函数和handle-signal函数都完成了哪些工作？？？（核心机制）" class="headerlink" title="do_signal函数和handle_signal函数都完成了哪些工作？？？（核心机制）"></a>do_signal函数和handle_signal函数都完成了哪些工作？？？（核心机制）</h1><p>存在哪些信号<br>信号的产生<br>注册信号处理函数<br>（内核对处理函数的记录和调用）（do_signal, handle_signal）</p>
<h1 id="What-the-function-do-signal-does"><a href="#What-the-function-do-signal-does" class="headerlink" title="What the function do_signal does?"></a>What the function do_signal does?</h1><p>do_signal 函数用来传递信号，它也是系统调用即将返回用户空间时对信号的预处理程序</p>
<h1 id="怎么样通过-handle-signal-函数来执行信号处理程序？？？"><a href="#怎么样通过-handle-signal-函数来执行信号处理程序？？？" class="headerlink" title="怎么样通过 handle_signal 函数来执行信号处理程序？？？"></a>怎么样通过 handle_signal 函数来执行信号处理程序？？？</h1><p>执行用户自定义的处理程序也叫 捕获信号</p>
<p>首先将保存在内核态堆栈上的硬件上下文拷贝到当前进程的用户态堆栈中，当信号处理程序终止时，自动调用 sigreturn 系统调用把这个硬件上下文拷贝回到内核态堆栈中，并恢复用户态堆栈中原来的内容。</p>
<h1 id="当有多个被挂起的信号等待被处理时，信号处理的流程是什么样的？？？"><a href="#当有多个被挂起的信号等待被处理时，信号处理的流程是什么样的？？？" class="headerlink" title="当有多个被挂起的信号等待被处理时，信号处理的流程是什么样的？？？"></a>当有多个被挂起的信号等待被处理时，信号处理的流程是什么样的？？？</h1><p>在 linux-0.11 中，好像是一次只能处理一个，待确认。。。<br>在最新版的内核中一次（调用一次do_signal）可以处理多个信号</p>
<h1 id="Some-classical-signal-produced-by-keyboard"><a href="#Some-classical-signal-produced-by-keyboard" class="headerlink" title="Some classical signal produced by keyboard??"></a>Some classical signal produced by keyboard??</h1><p>CTRL-C  SIGINT<br>CTRL-\  SIGABRT</p>
<p>下面两个是 non-catchable signal<br>CTRL-Z  SIGSTOP<br>kill -9 SIGKILL</p>
<p>上面两个信号究竟是 non-catchable 还是 unblocked?????</p>
<h1 id="How-the-alarm-is-implement"><a href="#How-the-alarm-is-implement" class="headerlink" title="How the alarm is implement?"></a>How the alarm is implement?</h1><p>“kernel&#x2F;time&#x2F;itimer.c”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For backwards compatibility?  This can be done in libc so Alpha</span></span><br><span class="line"><span class="comment"> * and all newer ports shouldn&#x27;t need it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(alarm, <span class="type">unsigned</span> <span class="type">int</span>, seconds)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> alarm_setitimer(seconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alarm_setitimer - set alarm in seconds</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @seconds:    number of seconds until alarm</span></span><br><span class="line"><span class="comment"> *              0 disables the alarm</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the remaining time in seconds of a pending timer or 0 when</span></span><br><span class="line"><span class="comment"> * the timer is not active.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On 32 bit machines the seconds value is limited to (INT_MAX/2) to avoid</span></span><br><span class="line"><span class="comment"> * negative timeval settings which would cause immediate expiry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm_setitimer</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec64</span> <span class="title">it_new</span>, <span class="title">it_old</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> BITS_PER_LONG &lt; 64</span></span><br><span class="line">        <span class="keyword">if</span> (seconds &gt; INT_MAX)</span><br><span class="line">                seconds = INT_MAX;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        it_new.it_value.tv_sec = seconds;</span><br><span class="line">        it_new.it_value.tv_nsec = <span class="number">0</span>;</span><br><span class="line">        it_new.it_interval.tv_sec = it_new.it_interval.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        do_setitimer(ITIMER_REAL, &amp;it_new, &amp;it_old);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We can&#x27;t return 0 if we have an alarm pending ...  And we&#x27;d</span></span><br><span class="line"><span class="comment">         * better return too much than too little anyway</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((!it_old.it_value.tv_sec &amp;&amp; it_old.it_value.tv_nsec) ||</span><br><span class="line">              it_old.it_value.tv_nsec &gt;= (NSEC_PER_SEC / <span class="number">2</span>))</span><br><span class="line">                it_old.it_value.tv_sec++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> it_old.it_value.tv_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Returns true if the timeval is in canonical form</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> timeval_valid(t) \</span></span><br><span class="line"><span class="meta">        (((t)-&gt;tv_sec &gt;= 0) &amp;&amp; (((unsigned long) (t)-&gt;tv_usec) &lt; USEC_PER_SEC))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_setitimer</span><span class="params">(<span class="type">int</span> which, <span class="keyword">struct</span> itimerspec64 *value,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> itimerspec64 *ovalue)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> *<span class="title">timer</span>;</span></span><br><span class="line">        <span class="type">ktime_t</span> expires;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (which) &#123;</span><br><span class="line">        <span class="keyword">case</span> ITIMER_REAL:</span><br><span class="line">again:</span><br><span class="line">                spin_lock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line">                timer = &amp;tsk-&gt;signal-&gt;real_timer;</span><br><span class="line">                <span class="keyword">if</span> (ovalue) &#123;</span><br><span class="line">                        ovalue-&gt;it_value = itimer_get_remtime(timer);</span><br><span class="line">                        ovalue-&gt;it_interval</span><br><span class="line">                                = ktime_to_timespec64(tsk-&gt;signal-&gt;it_real_incr);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* We are sharing -&gt;siglock with it_real_fn() */</span></span><br><span class="line">                <span class="keyword">if</span> (hrtimer_try_to_cancel(timer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        spin_unlock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line">                        hrtimer_cancel_wait_running(timer);</span><br><span class="line">                        <span class="keyword">goto</span> again;</span><br><span class="line">                &#125;</span><br><span class="line">                expires = timespec64_to_ktime(value-&gt;it_value);</span><br><span class="line">                <span class="keyword">if</span> (expires != <span class="number">0</span>) &#123;</span><br><span class="line">                        tsk-&gt;signal-&gt;it_real_incr =</span><br><span class="line">                                timespec64_to_ktime(value-&gt;it_interval);</span><br><span class="line">                        hrtimer_start(timer, expires, HRTIMER_MODE_REL);</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                        tsk-&gt;signal-&gt;it_real_incr = <span class="number">0</span>;</span><br><span class="line">                trace_itimer_state(ITIMER_REAL, value, <span class="number">0</span>);</span><br><span class="line">                spin_unlock_irq(&amp;tsk-&gt;sighand-&gt;siglock);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ITIMER_VIRTUAL:</span><br><span class="line">                set_cpu_itimer(tsk, CPUCLOCK_VIRT, value, ovalue);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ITIMER_PROF:</span><br><span class="line">                set_cpu_itimer(tsk, CPUCLOCK_PROF, value, ovalue);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“.&#x2F;kernel&#x2F;fork.c”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_signal</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);</span><br><span class="line">        tsk-&gt;signal = sig;</span><br><span class="line">        <span class="keyword">if</span> (!sig)</span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">        sig-&gt;nr_threads = <span class="number">1</span>;</span><br><span class="line">        <span class="type">atomic_set</span>(&amp;sig-&gt;live, <span class="number">1</span>);</span><br><span class="line">        refcount_set(&amp;sig-&gt;sigcnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */</span></span><br><span class="line">        sig-&gt;thread_head = (<span class="keyword">struct</span> list_head)LIST_HEAD_INIT(tsk-&gt;thread_node);</span><br><span class="line">        tsk-&gt;thread_node = (<span class="keyword">struct</span> list_head)LIST_HEAD_INIT(sig-&gt;thread_head);</span><br><span class="line"></span><br><span class="line">        init_waitqueue_head(&amp;sig-&gt;wait_chldexit);</span><br><span class="line">        sig-&gt;curr_target = tsk;</span><br><span class="line">        init_sigpending(&amp;sig-&gt;shared_pending);</span><br><span class="line">        INIT_HLIST_HEAD(&amp;sig-&gt;multiprocess);</span><br><span class="line">        seqlock_init(&amp;sig-&gt;stats_lock);</span><br><span class="line">        prev_cputime_init(&amp;sig-&gt;prev_cputime);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_POSIX_TIMERS</span></span><br><span class="line">        INIT_LIST_HEAD(&amp;sig-&gt;posix_timers);</span><br><span class="line">        hrtimer_init(&amp;sig-&gt;real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">        sig-&gt;real_timer.function = it_real_fn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        task_lock(current-&gt;group_leader);</span><br><span class="line">        <span class="built_in">memcpy</span>(sig-&gt;rlim, current-&gt;signal-&gt;rlim, <span class="keyword">sizeof</span> sig-&gt;rlim);</span><br><span class="line">        task_unlock(current-&gt;group_leader);</span><br><span class="line"></span><br><span class="line">        posix_cpu_timers_init_group(sig);</span><br><span class="line"></span><br><span class="line">        tty_audit_fork(sig);</span><br><span class="line">        sched_autogroup_fork(sig);</span><br><span class="line"></span><br><span class="line">        sig-&gt;oom_score_adj = current-&gt;signal-&gt;oom_score_adj;</span><br><span class="line">        sig-&gt;oom_score_adj_min = current-&gt;signal-&gt;oom_score_adj_min;</span><br><span class="line"></span><br><span class="line">        mutex_init(&amp;sig-&gt;cred_guard_mutex);</span><br><span class="line">        init_rwsem(&amp;sig-&gt;exec_update_lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>“kernel&#x2F;time&#x2F;itimer.c”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The timer is automagically restarted, when interval != 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> hrtimer_restart <span class="title function_">it_real_fn</span><span class="params">(<span class="keyword">struct</span> hrtimer *timer)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span> =</span></span><br><span class="line">                container_of(timer, <span class="keyword">struct</span> signal_struct, real_timer);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">leader_pid</span> =</span> sig-&gt;pids[PIDTYPE_TGID];</span><br><span class="line"></span><br><span class="line">        trace_itimer_expire(ITIMER_REAL, leader_pid, <span class="number">0</span>);</span><br><span class="line">        kill_pid_info(SIGALRM, SEND_SIG_PRIV, leader_pid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> HRTIMER_NORESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“kernel&#x2F;signal.c”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill_pid_info</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info, <span class="keyword">struct</span> pid *pid)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> error = -ESRCH;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                rcu_read_lock();</span><br><span class="line">                p = pid_task(pid, PIDTYPE_PID);</span><br><span class="line">                <span class="keyword">if</span> (p)</span><br><span class="line">                        error = group_send_sig_info(sig, info, p, PIDTYPE_TGID);</span><br><span class="line">                rcu_read_unlock();</span><br><span class="line">                <span class="keyword">if</span> (likely(!p || error != -ESRCH))</span><br><span class="line">                        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The task was unhashed in between, try again.  If it</span></span><br><span class="line"><span class="comment">                 * is dead, pid_task() will return NULL, if we race with</span></span><br><span class="line"><span class="comment">                 * de_thread() it will find the new leader.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * send signal info to all the members of a group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">group_send_sig_info</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> task_struct *p, <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        ret = check_kill_permission(sig, info, p);</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ret &amp;&amp; sig)</span><br><span class="line">                ret = do_send_sig_info(sig, info, p, type);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_send_sig_info</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info, <span class="keyword">struct</span> task_struct *p,</span></span><br><span class="line"><span class="params">                        <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">        <span class="type">int</span> ret = -ESRCH;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lock_task_sighand(p, &amp;flags)) &#123;</span><br><span class="line">                ret = send_signal(sig, info, p, type);</span><br><span class="line">                unlock_task_sighand(p, &amp;flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="如何给自己发送信号？"><a href="#如何给自己发送信号？" class="headerlink" title="如何给自己发送信号？"></a>如何给自己发送信号？</h1><p>raise() 不是系统调用，而是wrapper<br>glibc “.&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;raise.c”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">raise</span> <span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* rt_sigprocmask may fail if:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. sigsetsize != sizeof (sigset_t) (EINVAL)</span></span><br><span class="line"><span class="comment">     2. a failure in copy from/to user space (EFAULT)</span></span><br><span class="line"><span class="comment">     3. an invalid &#x27;how&#x27; operation (EINVAL)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The first case is already handle in glibc syscall call by using the arch</span></span><br><span class="line"><span class="comment">     defined _NSIG.  Second case is handled by using a stack allocated mask.</span></span><br><span class="line"><span class="comment">     The last one should be handled by the block/unblock functions.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">  __libc_signal_block_app (&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">  INTERNAL_SYSCALL_DECL (err);</span><br><span class="line">  <span class="type">pid_t</span> pid = INTERNAL_SYSCALL (getpid, err, <span class="number">0</span>);</span><br><span class="line">  <span class="type">pid_t</span> tid = INTERNAL_SYSCALL (gettid, err, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = INLINE_SYSCALL (tgkill, <span class="number">3</span>, pid, tid, sig);</span><br><span class="line"></span><br><span class="line">  __libc_signal_restore_set (&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (raise)</span><br><span class="line">weak_alias (raise, gsignal)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“kernel&#x2F;signal.c”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  sys_tgkill - send signal to one specific thread</span></span><br><span class="line"><span class="comment"> *  @tgid: the thread group ID of the thread</span></span><br><span class="line"><span class="comment"> *  @pid: the PID of the thread</span></span><br><span class="line"><span class="comment"> *  @sig: signal to be sent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This syscall also checks the @tgid and returns -ESRCH even if the PID</span></span><br><span class="line"><span class="comment"> *  exists but it&#x27;s not belonging to the target process anymore. This</span></span><br><span class="line"><span class="comment"> *  method solves the problem of threads exiting and PIDs getting reused.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(tgkill, <span class="type">pid_t</span>, tgid, <span class="type">pid_t</span>, pid, <span class="type">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* This is only valid for single tasks */</span></span><br><span class="line">        <span class="keyword">if</span> (pid &lt;= <span class="number">0</span> || tgid &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> do_tkill(tgid, pid, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_tkill</span><span class="params">(<span class="type">pid_t</span> tgid, <span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kernel_siginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">        clear_siginfo(&amp;info);</span><br><span class="line">        info.si_signo = sig;</span><br><span class="line">        info.si_errno = <span class="number">0</span>;</span><br><span class="line">        info.si_code = SI_TKILL;</span><br><span class="line">        info.si_pid = task_tgid_vnr(current);</span><br><span class="line">        info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> do_send_specific(tgid, pid, sig, &amp;info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">do_send_specific</span><span class="params">(<span class="type">pid_t</span> tgid, <span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">        <span class="type">int</span> error = -ESRCH;</span><br><span class="line"></span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        p = find_task_by_vpid(pid);</span><br><span class="line">        <span class="keyword">if</span> (p &amp;&amp; (tgid &lt;= <span class="number">0</span> || task_tgid_vnr(p) == tgid)) &#123;</span><br><span class="line">                error = check_kill_permission(sig, info, p);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * The null signal is a permissions and process existence</span></span><br><span class="line"><span class="comment">                 * probe.  No signal is actually delivered.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!error &amp;&amp; sig) &#123;</span><br><span class="line">                        error = do_send_sig_info(sig, info, p, PIDTYPE_PID);</span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                         * If lock_task_sighand() failed we pretend the task</span></span><br><span class="line"><span class="comment">                         * dies after receiving the signal. The window is tiny,</span></span><br><span class="line"><span class="comment">                         * and the signal is private anyway.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (unlikely(error == -ESRCH))</span><br><span class="line">                                error = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_send_sig_info</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info, <span class="keyword">struct</span> task_struct *p,</span></span><br><span class="line"><span class="params">                        <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">        <span class="type">int</span> ret = -ESRCH;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lock_task_sighand(p, &amp;flags)) &#123;</span><br><span class="line">                ret = send_signal(sig, info, p, type);</span><br><span class="line">                unlock_task_sighand(p, &amp;flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">send_signal</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info, <span class="keyword">struct</span> task_struct *t,</span></span><br><span class="line"><span class="params">                        <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Should SIGKILL or SIGSTOP be received by a pid namespace init? */</span></span><br><span class="line">        <span class="type">bool</span> force = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info == SEND_SIG_NOINFO) &#123;</span><br><span class="line">                <span class="comment">/* Force if sent from an ancestor pid namespace */</span></span><br><span class="line">                force = !task_pid_nr_ns(current, task_active_pid_ns(t));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info == SEND_SIG_PRIV) &#123;</span><br><span class="line">                <span class="comment">/* Don&#x27;t ignore kernel generated signals */</span></span><br><span class="line">                force = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (has_si_pid_and_uid(info)) &#123;</span><br><span class="line">                <span class="comment">/* SIGKILL and SIGSTOP is special or has ids */</span></span><br><span class="line">                <span class="keyword">struct</span> user_namespace *t_user_ns;</span><br><span class="line"></span><br><span class="line">                rcu_read_lock();</span><br><span class="line">                t_user_ns = task_cred_xxx(t, user_ns);</span><br><span class="line">                <span class="keyword">if</span> (current_user_ns() != t_user_ns) &#123;</span><br><span class="line">                        <span class="type">kuid_t</span> uid = make_kuid(current_user_ns(), info-&gt;si_uid);</span><br><span class="line">                        info-&gt;si_uid = from_kuid_munged(t_user_ns, uid);</span><br><span class="line">                &#125;</span><br><span class="line">                rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* A kernel generated signal? */</span></span><br><span class="line">                force = (info-&gt;si_code == SI_KERNEL);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* From an ancestor pid namespace? */</span></span><br><span class="line">                <span class="keyword">if</span> (!task_pid_nr_ns(current, task_active_pid_ns(t))) &#123;</span><br><span class="line">                        info-&gt;si_pid = <span class="number">0</span>;</span><br><span class="line">                        force = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> __send_signal(sig, info, t, type, force);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __send_signal(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info, <span class="keyword">struct</span> task_struct *t,</span><br><span class="line">                        <span class="keyword">enum</span> pid_type type, <span class="type">bool</span> force)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line">        <span class="type">int</span> override_rlimit;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line"></span><br><span class="line">        assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">        result = TRACE_SIGNAL_IGNORED;</span><br><span class="line">        <span class="keyword">if</span> (!prepare_signal(sig, t, force))</span><br><span class="line">                <span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">        pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Short-circuit ignored signals and support queuing</span></span><br><span class="line"><span class="comment">         * exactly one non-rt signal, so that we can get more</span></span><br><span class="line"><span class="comment">         * detailed information about the cause of the signal.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        result = TRACE_SIGNAL_ALREADY_PENDING;</span><br><span class="line">        <span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line">                <span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">        result = TRACE_SIGNAL_DELIVERED;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Skip useless siginfo allocation for SIGKILL and kernel threads.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((sig == SIGKILL) || (t-&gt;flags &amp; PF_KTHREAD))</span><br><span class="line">                <span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Real-time signals must be queued if sent by sigqueue, or</span></span><br><span class="line"><span class="comment">         * some other real-time mechanism.  It is implementation</span></span><br><span class="line"><span class="comment">         * defined whether kill() does so.  We attempt to do so, on</span></span><br><span class="line"><span class="comment">         * the principle of least surprise, but since kill is not</span></span><br><span class="line"><span class="comment">         * allowed to fail with EAGAIN when low on memory we just</span></span><br><span class="line"><span class="comment">         * make sure at least one signal gets delivered and don&#x27;t</span></span><br><span class="line"><span class="comment">         * pass on the info struct.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">                override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (q) &#123;</span><br><span class="line">                list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line">                <span class="keyword">switch</span> ((<span class="type">unsigned</span> <span class="type">long</span>) info) &#123;</span><br><span class="line">                <span class="keyword">case</span> (<span class="type">unsigned</span> <span class="type">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">                        clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">                        q-&gt;info.si_signo = sig;</span><br><span class="line">                        q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">                        q-&gt;info.si_code = SI_USER;</span><br><span class="line">                        q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">                                                        task_active_pid_ns(t));</span><br><span class="line">                        rcu_read_lock();</span><br><span class="line">                        q-&gt;info.si_uid =</span><br><span class="line">                                from_kuid_munged(task_cred_xxx(t, user_ns),</span><br><span class="line">                                                 current_uid());</span><br><span class="line">                        rcu_read_unlock();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> (<span class="type">unsigned</span> <span class="type">long</span>) SEND_SIG_PRIV:</span><br><span class="line">                        clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">                        q-&gt;info.si_signo = sig;</span><br><span class="line">                        q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">                        q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">                        q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">                        q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                        copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info) &amp;&amp;</span><br><span class="line">                   sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Queue overflow, abort.  We may abort if the</span></span><br><span class="line"><span class="comment">                 * signal was rt and sent by user using something</span></span><br><span class="line"><span class="comment">                 * other than kill().</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                result = TRACE_SIGNAL_OVERFLOW_FAIL;</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">                <span class="keyword">goto</span> ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * This is a silent loss of information.  We still</span></span><br><span class="line"><span class="comment">                 * send the signal, but the *info bits are lost.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                result = TRACE_SIGNAL_LOSE_INFO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">        signalfd_notify(t, sig);</span><br><span class="line">        sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Let multiprocess signals appear after on-going forks */</span></span><br><span class="line">        <span class="keyword">if</span> (type &gt; PIDTYPE_TGID) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">multiprocess_signals</span> *<span class="title">delayed</span>;</span></span><br><span class="line">                hlist_for_each_entry(delayed, &amp;t-&gt;signal-&gt;multiprocess, node) &#123;</span><br><span class="line">                        <span class="type">sigset_t</span> *signal = &amp;delayed-&gt;signal;</span><br><span class="line">                        <span class="comment">/* Can&#x27;t queue both a stop and a continue signal */</span></span><br><span class="line">                        <span class="keyword">if</span> (sig == SIGCONT)</span><br><span class="line">                                sigdelsetmask(signal, SIG_KERNEL_STOP_MASK);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (sig_kernel_stop(sig))</span><br><span class="line">                                sigdelset(signal, SIGCONT);</span><br><span class="line">                        sigaddset(signal, sig);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        complete_signal(sig, t, type);</span><br><span class="line">ret:</span><br><span class="line">        trace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>The Linux Signals Handling Model<br><a target="_blank" rel="noopener" href="https://www.linuxjournal.com/article/3985">https://www.linuxjournal.com/article/3985</a></p>
<h1 id="keyword"><a href="#keyword" class="headerlink" title="keyword"></a>keyword</h1><p>IPC(inter-process communication)<br>signal model<br>signal blocking and pending</p>
<hr>
<h1 id="permission-check"><a href="#permission-check" class="headerlink" title="permission check"></a>permission check</h1><p> (内核进程的权限检查)</p>
<h1 id="How-to-support-critical-region-and-masking-signal"><a href="#How-to-support-critical-region-and-masking-signal" class="headerlink" title="How to support critical region and masking signal"></a>How to support critical region and masking signal</h1><p>（内核需要 mask signal）（与中断保护临界区有点像）<br>（当mask的信号被pending时，如何记录？）</p>
<h1 id="内核设置handle时对-SIGKILL-and-SIGSTOP-的检查"><a href="#内核设置handle时对-SIGKILL-and-SIGSTOP-的检查" class="headerlink" title="内核设置handle时对 SIGKILL and SIGSTOP 的检查"></a>内核设置handle时对 SIGKILL and SIGSTOP 的检查</h1><h1 id="内核在多线程环境下的信号分发策略"><a href="#内核在多线程环境下的信号分发策略" class="headerlink" title="内核在多线程环境下的信号分发策略"></a>内核在多线程环境下的信号分发策略</h1><h1 id="内核对被信号打断的系统调用重启的支持"><a href="#内核对被信号打断的系统调用重启的支持" class="headerlink" title="内核对被信号打断的系统调用重启的支持"></a>内核对被信号打断的系统调用重启的支持</h1><h1 id="内核对sigaction-和-signal的支持区别在哪？"><a href="#内核对sigaction-和-signal的支持区别在哪？" class="headerlink" title="内核对sigaction 和 signal的支持区别在哪？"></a>内核对sigaction 和 signal的支持区别在哪？</h1><h1 id="与信号相关的系统调用如何实现"><a href="#与信号相关的系统调用如何实现" class="headerlink" title="与信号相关的系统调用如何实现"></a>与信号相关的系统调用如何实现</h1><hr>
<h1 id="linux-signal-produce-and-delivery"><a href="#linux-signal-produce-and-delivery" class="headerlink" title="linux signal produce and delivery"></a>linux signal produce and delivery</h1><h2 id="try-one-simple-example"><a href="#try-one-simple-example" class="headerlink" title="try one simple example"></a>try one simple example</h2><ol>
<li><p>to set the signal handler for a program, and run it</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Here is the %dth signal\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> global = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGINT, sig_handler);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;waiting for signal\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>after run this program, one need to press the key CTRL-C to produce signal.</p>
</li>
</ol>
<h1 id="How-many-signals-can-we-produce"><a href="#How-many-signals-can-we-produce" class="headerlink" title="How many signals can we produce?"></a>How many signals can we produce?</h1><p>To use command “kill -l” list the system support signals.</p>
<h1 id="Which-common-scenarios-are-related-to-signals"><a href="#Which-common-scenarios-are-related-to-signals" class="headerlink" title="Which common scenarios are related to signals?"></a>Which common scenarios are related to signals?</h1><p>Core file<br>SIGTERM 来清理一些程序生成的临时文件<br>pause()系统调用<br>alarm signal<br>typing the interrupt key to stop a program at a terminal<br>when the process exit, it will send SIGCHLD to parent process<br>SIGSEGV</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1. to kill()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kernel<span class="emphasis">_siginfo</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">kill</span></span><br><span class="line"><span class="emphasis">	kill_</span>something<span class="emphasis">_info()</span></span><br><span class="line"><span class="emphasis">		kill_</span>proc<span class="emphasis">_info</span></span><br><span class="line"><span class="emphasis">			kill_</span>pid<span class="emphasis">_info</span></span><br><span class="line"><span class="emphasis">				group_</span>send<span class="emphasis">_sig_</span>info</span><br><span class="line"><span class="code">					do_send_sig_info</span></span><br><span class="line"><span class="code">						send_signal</span></span><br><span class="line"><span class="code">		__kill_pgrp_info</span></span><br><span class="line"><span class="code">		group_send_sig_info</span></span><br><span class="line"><span class="code">			do_send_sig_info</span></span><br><span class="line"><span class="code">				send_signal</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">tgkill</span></span><br><span class="line"><span class="code">	do_tkill</span></span><br><span class="line"><span class="code">		do_send_specific</span></span><br><span class="line"><span class="code">			do_send_sig_info</span></span><br><span class="line"><span class="code">				send_signal</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 2. to alarm</span></span><br><span class="line"></span><br><span class="line">it<span class="emphasis">_real_</span>fn</span><br><span class="line"><span class="code">	kill_pid_info</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section"># 3. to exit</span></span><br><span class="line">do<span class="emphasis">_exit</span></span><br><span class="line"><span class="emphasis">	exit_</span>notity</span><br><span class="line"><span class="code">		do_notify_parent</span></span><br><span class="line"><span class="code">			__send_signal</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4. tty (CTRL-C)</span></span><br><span class="line">???????????????????</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====&gt; send<span class="emphasis">_signal</span></span><br><span class="line"><span class="emphasis">(when and how to handle)</span></span><br></pre></td></tr></table></figure>



<h1 id="how-to-produce-signal"><a href="#how-to-produce-signal" class="headerlink" title="how to produce signal?"></a>how to produce signal?</h1><p>specific_send_sig_info()<br>group_send_sig_info()</p>
<p>send_signal</p>
<h1 id="how-to-delivery-signal"><a href="#how-to-delivery-signal" class="headerlink" title="how to delivery signal?"></a>how to delivery signal?</h1><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do_signal</span><br><span class="line">	dequeue_signal() (until no nonblocked pending signals are left in both the private and shared pending signal queues)</span><br><span class="line">		1. ignoring the signal</span><br><span class="line"></span><br><span class="line">		2. executing a default action</span><br><span class="line">		    The signals whose default action is “dump” may create a core file in the process working directory</span><br><span class="line">	    3. executing a signal handler</span><br><span class="line">            Handle_signal</span><br></pre></td></tr></table></figure>
<h2 id="executing-a-signal-handler"><a href="#executing-a-signal-handler" class="headerlink" title="executing a signal handler"></a>executing a signal handler</h2><h3 id="执行一个信号处理程序将会遇到哪些问题？？？"><a href="#执行一个信号处理程序将会遇到哪些问题？？？" class="headerlink" title="执行一个信号处理程序将会遇到哪些问题？？？"></a>执行一个信号处理程序将会遇到哪些问题？？？</h3><ol>
<li><p>信号处理程序是用户态进程所定义的函数，被包含在用户态代码段中。而函数 handle_signal 运行在内核态。即为了执行信号处理程序，我们需要在用户态和内核态之间进行切换</p>
</li>
<li><p>当前进程恢复到正常的系统调用完成后用户的执行状态前，该进程首先需要执行信号处理程序</p>
</li>
<li><p>当进程从内核态返回到用户态时，内核态堆栈就会被清空，所以内核态堆栈不再包含被中断程序的硬件上下文</p>
</li>
<li><p>信号处理程序可以执行系统调用，所以当发生在信号处理程序中的系统调用返回时，它需要回到信号处理程序中，而不是被中断程序的正常代码流（可以看出这个过程中需要把各种信息记录在用户空间中）</p>
</li>
</ol>
<h3 id="the-solution-for-above-problem"><a href="#the-solution-for-above-problem" class="headerlink" title="the solution for above problem"></a>the solution for above problem</h3><p>copying the hardware context saved in the kernel mode stack onto the user mode stack of the current process.</p>
<p>when the signal handler terminates, the sigreturn() system call is automatically invoked to copy the hardware context back on the kernel mode stack and to restore the original content of the user mode stack.</p>
<p>right before returning to user mode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do_signal</span><br><span class="line">    handle_signal</span><br><span class="line">        setup_frame / setup_rt_frame</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>switch to user mode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">executing the signal handler</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>when function terminates, the return code invokes the sigreturn, the corresponding service routines copy the hardware context of the normal program to the kernel mode stack and restore the user mode stack back to its original state.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">returncode</span><br><span class="line">    sigreturn /  rt_sigreturn</span><br><span class="line">        restore_sigcontext</span><br></pre></td></tr></table></figure>


<p>when the system call terminates, the normal program can thus resume its execution.</p>
<h3 id="How-to-implement-the-above-step"><a href="#How-to-implement-the-above-step" class="headerlink" title="How to implement the above step?"></a>How to implement the above step?</h3><p>首先将内核态现场保存到进程的用户态栈帧中，然后按照子函数调用的栈帧结构在用户态堆栈中插入一个调用信号处理程序的栈帧，这样当返回到用户态时就可以开始执行信号处理程序，在信号处理程序执行完成后，再次进入内核将之前保存的被中断现场恢复回来，然后继续执行</p>
<p>在通过 sig_handler 的方式来 delivery signal 的时候，涉及两个关键问题，1. 如何开始执行 signal handler 2. 执行完 signal handler 之后如何恢复到原来被中断的现场继续执行</p>
<p>在解决这两个关键问题的过程中，主要要涉及对栈帧的修改，以及对被中断现场的保存和恢复</p>
<h1 id="信号处理函数执行完成后为啥还要回到内核态去恢复现场？？（直接跳到正常的执行流程不行吗？？）"><a href="#信号处理函数执行完成后为啥还要回到内核态去恢复现场？？（直接跳到正常的执行流程不行吗？？）" class="headerlink" title="信号处理函数执行完成后为啥还要回到内核态去恢复现场？？（直接跳到正常的执行流程不行吗？？）"></a>信号处理函数执行完成后为啥还要回到内核态去恢复现场？？（直接跳到正常的执行流程不行吗？？）</h1><h1 id="发生信号的时候，正常的执行流的上下文保存在哪？？（在内核态堆栈还是用户态异常堆栈？？？）"><a href="#发生信号的时候，正常的执行流的上下文保存在哪？？（在内核态堆栈还是用户态异常堆栈？？？）" class="headerlink" title="发生信号的时候，正常的执行流的上下文保存在哪？？（在内核态堆栈还是用户态异常堆栈？？？）"></a>发生信号的时候，正常的执行流的上下文保存在哪？？（在内核态堆栈还是用户态异常堆栈？？？）</h1><p>Ref</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Longyu_wlz/article/details/109350395">https://blog.csdn.net/Longyu_wlz/article/details/109350395</a><br><a href="https://gitee.com/aosp-riscv/working-group/blob/master/articles/20220816-signal-frame.md#https://gitee.com/link?target=https%3A%2F%2Fblog.csdn.net%2FLongyu_wlz%2Farticle%2Fdetails%2F109350395">https://gitee.com/aosp-riscv/working-group/blob/master/articles/20220816-signal-frame.md#https://gitee.com/link?target=https%3A%2F%2Fblog.csdn.net%2FLongyu_wlz%2Farticle%2Fdetails%2F109350395</a></p>
<h1 id="how-to-config-signal-disposition"><a href="#how-to-config-signal-disposition" class="headerlink" title="how to config signal disposition?"></a>how to config signal disposition?</h1>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>youngvoice
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://youngvoice.github.io/2023/07/08/Linux_Signals/" title="the mechanism of linux signal">https://youngvoice.github.io/2023/07/08/Linux_Signals/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/cs/" rel="tag"># cs</a>
              <a href="/tags/linux/" rel="tag"># linux</a>
              <a href="/tags/signal/" rel="tag"># signal</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/18/setjmp_longjmp/" rel="prev" title="jump between different function">
                  <i class="fa fa-chevron-left"></i> jump between different function
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/24/exponential_logarithmic/" rel="next" title="exponential and logarithmic">
                  exponential and logarithmic <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youngvoice</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  


  <script class="next-config" data-name="leancloud_visitors" type="application/json">{"enable":true,"app_id":"KXmlfX5j58VDYijiWp6nSyxa-gzGzoHsz","app_key":"icP17WRY0W95wXZ7w7X0pDd2","server_url":null,"security":false}</script>
  <script src="/js/third-party/statistics/lean-analytics.js"></script>


  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"youngvoice/comment.youngvoice.github.io","issue_term":"title","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
